<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to ARIMA Models Using R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Laura Rose" />
    <meta name="date" content="2022-04-19" />
    <script src="Intro-to-ARIMA_files/header-attrs-2.9/header-attrs.js"></script>
    <link href="Intro-to-ARIMA_files/remark-css-0.0.1/rladies.css" rel="stylesheet" />
    <link href="Intro-to-ARIMA_files/remark-css-0.0.1/rladies-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introduction to ARIMA Models Using R
### Laura Rose
### April 19, 2022

---




## Intro to ARIMA Models
- ARIMA models are one of the most common univariate time series forecasting methods.

--

- ARIMA stands for **A**uto**R**egressive **I**ntegrated **M**oving **A**verage.

--

- We will explore each part of the ARIMA model in detail before moving on to its implementation in R.

---

## For Further Reading
- Hyndman, R.J., &amp; Athanasopoulos, G. (2021) *Forecasting: principles and practice*, 3rd edition, OTexts: Melbourne, Australia. OTexts.com/fpp3. Accessed on March 3, 2022.
- Brooks, C. (2008). *Introductory Econometrics for Finance*, 2nd edition, Cambridge University Press: Cambridge, United Kingdom.

---

## Stationarity
- A time series is said to be *strictly stationary* if the distribution of the observations does not change across time.

--

- However, strict stationarity is not always necessary to model a time series. We often reference *weak stationarity* in our analysis.

--

- `\(E(y_{t}) = \mu\)` (constant mean)

--

- `\(E[(y_{t} - \mu)(y_{t} - \mu)] = \sigma^2 &lt; \infty\)` (constant variance)

--

- `\(E[(y_{t_{k}} - \mu)(y_{t_{k'}} - \mu)] = \gamma_{t_{k}-t_{k'}} \space \forall \space t_{k}, t_{k'}\)` (constant autocovariance)

--
  - When `\(k = k'\)`, the autocovariance is the variance.
  
--

- The autocovariance is not particularly useful since it is scale-dependent. Therefore, we often normalize the autocovariance by dividing by the variance.

--

- This is called the *autocorrelation*, and this measure has the usefulness of being bounded between `\(\pm1\)`

---

## White Noise Process

- A *white noise process* is a special case of a stationary process.

--

`$$E(y_{t}) = 0$$`

--

`$$E[(y_{t} - \mu)(y_{t} - \mu)] = \sigma^2$$`

--

`$$\gamma_{k-k'} = \left\{\begin{aligned}
&amp;\sigma^2 &amp;&amp;if \space k = k'\\
&amp;0 &amp;&amp; otherwise
\end{aligned}
\right.$$`

--

- *Note that some definitions of a white noise process indicate a nonzero mean is permissible.*

---

## What to Do If Data is Nonstationary?
- So what happens if we find our data violates any of the (weak) stationarity conditions?

--

- Note that data with trend or seasonality is not stationary, but data with cyclic behavior (i.e., business or other cycles which are not of fixed length) can be stationary.

--

- Differencing the series is a common way to deal with nonstationarity resulting from autocorrelation. 

--

  - The difference of a value with the previous value is called *first-order differencing*: `\(y'_{t} = y_{t} - y_{t-1}\)`.
  
--

  - Sometimes this is not enough to make the series stationary, so we take the difference of the differences.

--

`$$\begin{align*}
  y''_{t}  &amp;=  y'_{t}  - y'_{t - 1} \\
           &amp;= (y_t - y_{t-1}) - (y_{t-1}-y_{t-2})\\
           &amp;= y_t - 2y_{t-1} +y_{t-2}
\end{align*}$$`
--

- If we notice a seasonal pattern, we can take a seasonal difference: `\(y'_{t} = y_{t} - y_{t-m}\)`, where `\(m\)` is the seasonal period. 

---

## What to Do if Data is Nonstationary, cont.

- If the data looks like it may require both first-differencing and seasonal differencing, it's better to take the seasonal difference first.

--

- This is especially true in the case of strong seasonality, since sometimes taking a seasonal difference is enough to make the series stationary.

--

- However, taking a first difference will not get rid of seasonal stationarity.

--

- Always use as few differences as possible, since too much differencing can induce patterns in the series that are not actually there.

--

- If the variance appears nonconstant across time, a logarithmic transformation can be used to stabilize.

---

## How to Test for Nonstationarity

- There are both formal and nonformal ways to examine the time series.

--

- We should always start by plotting the time series (line plot is generally best), since often nonstationarity and nonconstant variance are visible to the human eye.

--

- If we suspect nonstationarity, we should plot the autocorrelation function (ACF) and check for observations outside of the 95% confidence interval around 0. We particularly want to examine how quickly these autocorrelations drop to 0.

--

- To formally test for stationarity, we conduct a *unit root test*.

--

- Taking a cue from Dr. Hyndman, we will use the KPSS test, but other tests are available (ADF and PP tests).

--

- A *unit root* implies that the data is essentially a function of its lag(s) where the coefficient equals 1, plus some noise. (There are some variations on this, but we will skip discussion for the sake of simplicity.)
  - In more formal terms, the root of the characteristic equation equals 1.

---

## An Example of Checking for Stationarity

.pull_left[

```r
data(BJsales)
date.sequence &lt;- seq(as.Date("1955-01-01"), 
by = "month", length.out = 150)
Sales_tsib &lt;- tsibble(Month = yearmonth(date.sequence), 
Sales = BJsales, index = Month)
autoplot(Sales_tsib)
```
]

--

.pull_right[
&lt;img src="Intro-to-ARIMA_files/figure-html/unnamed-chunk-1-1.png" width="648" /&gt;
]

---

## Checking the ACF

.pull_left[

```r
Sales_tsib %&gt;% ACF() %&gt;% autoplot()
```
]

--

.pull_right[
&lt;img src="Intro-to-ARIMA_files/figure-html/unnamed-chunk-2-1.png" width="648" /&gt;
]

---

## Testing for a Unit Root 


```r
uroot_table &lt;- Sales_tsib %&gt;% 
features(Sales, unitroot_kpss) %&gt;% 
bind_cols(Sales_tsib %&gt;%
features(Sales, unitroot_ndiffs)) %&gt;% 
bind_cols(Sales_tsib %&gt;% 
features(Sales, unitroot_nsdiffs))
knitr::kable(uroot_table, format = "html",
digits = 2, align = "c")
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:center;"&gt; kpss_stat &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; kpss_pvalue &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; ndiffs &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; nsdiffs &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; 2.62 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0.01 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

--

- We clearly have a unit root (we reject the null hypothesis of stationarity), but it doesn't look like we will need to take a seasonal difference.

---

## Backshift Notation

- This notation is a helpful (hopefully!) shorthand to describe lags of variables for easier manipulation. Think of `\(B\)` as "backshift." Some books/sites also use `\(L\)` for "lag".

--

- `\(By_{t} = y_{t-1}\)`

--

- By extension, `\(B(By_{t}) = B^2y_{t} = y_{t-2}\)`, etc.

--

- Same quarter last year would be `\(B^4y_{t} = y_{t-4}\)`

--

- We can also use the backshift operator to describe differencing.
`$$y' = y_{t} - y_{t-1} = y_{t} - By_{t} = (1-B)y_{t}$$`
- We can treat the expressions in `\(B\)` like polynomials and solve for roots (thus the unit root concept).
  
--

`$$\begin{align*}
y'' &amp;= (y_{t} - y_{t-1}) - (y_{t-1} - y_{t-2})\\ 
    &amp;= y_{t} - By_{t} - By_{t} + B^2y_{t}\\ 
    &amp;= y_{t} - 2By_{t} + B^2y_{t}\\ 
    &amp;= (B-1)^2y_{t}\\ 
    &amp;= (1-B)^2y_{t}
\end{align*}$$`
  

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
